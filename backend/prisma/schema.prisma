// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // bcrypt hashed
  name      String?
  createdAt DateTime @default(now())

  // Study preferences
  maxReviewsPerDay Int @default(100)
  maxNewCardsPerDay Int @default(10)

  // Badge data (stored as JSON array)
  badges    Json     @default("[]")

  // Gamification fields
  xp            Int      @default(0)
  level         Int      @default(1)
  xpToNextLevel Int      @default(100)
  title         String   @default("Comatose Newbie")
  currentCombo  Int      @default(0)
  highestCombo  Int      @default(0)
  totalXpEarned Int      @default(0)
  streak        Int      @default(0)
  lastStudyDate DateTime?

  nodes     Node[]
  cards     Card[]
  reviews   Review[]
}

model Node {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  name        String
  summary     String?
  module      String?  // 'Spinal' | 'Brainstem' | 'Cerebrum' | 'CSF' | 'Clinical' | 'Other'
  parentId    String?
  parent      Node?    @relation("NodeHierarchy", fields: [parentId], references: [id])
  children    Node[]   @relation("NodeHierarchy")

  tags        String[] // Array of tags
  mainImageUrl String? // URL to primary diagram/image for this node

  // Computed fields (updated by trigger/function)
  nodeStrength Float   @default(0)
  lastReviewed DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  facts       Fact[]
  images      NodeImage[]
  cards       Card[]
  steps       NodeStep[]

  // Relationships where this node is the source
  sourceRelationships NodeRelationship[] @relation("SourceNode")
  // Relationships where this node is the target
  targetRelationships NodeRelationship[] @relation("TargetNode")

  @@index([userId, nodeStrength])
  @@index([userId, parentId])
  @@index([userId, module])
}

model NodeRelationship {
  id        String   @id @default(cuid())

  sourceNodeId String
  sourceNode   Node   @relation("SourceNode", fields: [sourceNodeId], references: [id], onDelete: Cascade)

  targetNodeId String
  targetNode   Node   @relation("TargetNode", fields: [targetNodeId], references: [id], onDelete: Cascade)

  relationshipType String // 'prerequisite' | 'compare' | 'part_of' | 'related' | 'pathway'
  notes            String? // Optional explanation
  strength         Int     @default(5) // 0-10 importance (for future use)

  createdAt DateTime @default(now())

  @@index([sourceNodeId])
  @@index([targetNodeId])
  @@index([relationshipType])
}

model NodeStep {
  id        String   @id @default(cuid())
  nodeId    String
  node      Node     @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  stepNumber   Int      // Order in the sequence (1, 2, 3...)
  title        String   // Step title (e.g., "Check pupillary light reflex")
  content      String   // Detailed instructions/description

  // Decision/branching support
  decisionPoint Boolean @default(false) // Is this a decision point?
  nextSteps     Json?   // Array of {condition: string, nextStepNumber: int}

  // Optional media
  imageUrl     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([nodeId, stepNumber])
  @@unique([nodeId, stepNumber])
}

model Fact {
  id        String   @id @default(cuid())
  nodeId    String
  node      Node     @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  statement String   // The actual fact text
  factType  String   // definition, association, localization, comparison, etc.
  keyTerms  String[] // Extracted key terms

  createdAt DateTime @default(now())

  cards     Card[]
  images    FactImage[]
}

model Card {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  nodeId    String
  node      Node     @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  factId    String?
  fact      Fact?    @relation(fields: [factId], references: [id], onDelete: Cascade)

  front     String
  back      String
  hint      String?

  // Card type
  cardType  String   // basic, reverse, cloze, image_occlusion

  // FSRS scheduling data (stored as JSON)
  fsrsData  Json     // { due, stability, difficulty, elapsed_days, scheduled_days, reps, lapses, state }

  // Images
  frontImageId String?
  backImageId  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviews   Review[]

  @@index([userId, nodeId])
}

model Review {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  cardId    String
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)

  rating    Int      // 0 = Again, 1 = Hard, 2 = Good, 3 = Easy
  grade     Float    // 0, 0.4, or 1.0 (for NodeStrength calculation)
  xpEarned  Int      @default(0)
  comboAtReview Int  @default(0)

  reviewedAt DateTime @default(now())

  @@index([userId, cardId])
  @@index([reviewedAt])
}

model NodeImage {
  id        String   @id @default(cuid())
  nodeId    String
  node      Node     @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  filename  String
  url       String   // URL or path to image
  imageType String   // base, annotated, variant

  // Optional: store image data directly in DB (for MVP)
  imageData Bytes?

  createdAt DateTime @default(now())
}

model FactImage {
  id        String   @id @default(cuid())
  factId    String
  fact      Fact     @relation(fields: [factId], references: [id], onDelete: Cascade)

  filename  String
  url       String
  imageType String
  imageData Bytes?

  createdAt DateTime @default(now())
}
